<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Code</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <!-- Three.js library for 3D graphics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            background-color: #000000; /* Solid black background */
            overflow: hidden;
            font-family: 'Inter', sans-serif;
        }

        .banner-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            /* Changed to position elements at the top and right */
            justify-content: flex-start;
            align-items: flex-end;
        }

        #starfield-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .text-container {
            position: relative;
            z-index: 2;
            text-align: right; /* Align text to the right */
            color: #ffffff;
            /* New: Added margins to position the text */
            margin-top: 2rem;
            margin-right: 2rem;
        }

        .developer-title {
            font-size: 1.5rem;
            margin-top: 0.5rem;
            font-weight: 400;
        }

        @media (min-width: 768px) {
            .developer-title {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="banner-container">
        <!-- Three.js will render to this canvas -->
        <canvas id="starfield-canvas"></canvas>
        <div class="text-container">
            <!-- Font size is now smaller -->
            <h1 class="text-3xl md:text-4xl font-bold rounded-lg">Omkar Acharya</h1>
            <h2 class="developer-title">Software Designer</h2>
        </div>
    </div>

    <script>
        // Use a self-invoking function to encapsulate variables
        (function() {
            // --- Three.js Scene Setup ---
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('starfield-canvas') });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // --- Lighting Setup (Added to fix the visibility issue) ---
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 1.5, 100);
            camera.add(pointLight);
            scene.add(camera);
            
            // --- Starfield Creation ---
            const starCount = 8000; // Increased star count for a more dense background
            const starGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const starColors = [new THREE.Color(0xffffff), new THREE.Color(0x6ee7b7)];

            for (let i = 0; i < starCount; i++) {
                // Random position within a sphere
                positions.push(
                    (Math.random() - 0.5) * 2000, 
                    (Math.random() - 0.5) * 2000, 
                    (Math.random() - 0.5) * 2000
                );
                // Assign a random color (white or light green)
                colors.push(starColors[Math.floor(Math.random() * 2)].r, starColors[Math.floor(Math.random() * 2)].g, starColors[Math.floor(Math.random() * 2)].b);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const starMaterial = new THREE.PointsMaterial({ size: 1.5, vertexColors: true, transparent: true, opacity: 0.8 });
            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);

            // --- Planet Creation ---
            const planets = [];
            const planetColors = [0x5f9ea0, 0xdaa520, 0x8a2be2, 0x008b8b, 0x2e8b57];
            let lastPlanetTime = 0;
            // Increased frequency for better visibility
            const minPlanetInterval = 1500; 
            
            // Helper function to create a procedural texture for the planets
            function createPlanetTexture(color) {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 32;
                const context = canvas.getContext('2d');
                
                context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                context.fillRect(0, 0, 64, 32);
                
                // Add some random noise for a mottled surface effect
                for (let i = 0; i < 500; i++) {
                    const x = Math.random() * 64;
                    const y = Math.random() * 32;
                    context.fillStyle = `rgba(0, 0, 0, ${Math.random() * 0.5})`;
                    context.fillRect(x, y, 1, 1);
                }
                
                return new THREE.CanvasTexture(canvas);
            }

            function createPlanet() {
                // Made planets larger and more prominent
                const planetSize = Math.random() * 40 + 15;
                const planetGeometry = new THREE.SphereGeometry(planetSize, 32, 32);
                const randomColor = planetColors[Math.floor(Math.random() * planetColors.length)];
                const texture = createPlanetTexture(randomColor);
                // Use MeshLambertMaterial for texture
                const planetMaterial = new THREE.MeshLambertMaterial({ map: texture });
                const planet = new THREE.Mesh(planetGeometry, planetMaterial);
                
                // Set initial position far away from the camera
                planet.position.x = (Math.random() - 0.5) * 1000;
                planet.position.y = (Math.random() - 0.5) * 1000;
                planet.position.z = -1500;
                
                // Hide planet initially and set scale to 0
                planet.scale.set(0, 0, 0);
                
                scene.add(planet);
                planets.push(planet);
            }

            // --- Animation Loop ---
            function animate() {
                requestAnimationFrame(animate);

                // Slower movement for a smoother feel
                starField.position.z += 0.8; 
                if (starField.position.z > 500) {
                    starField.position.z = 0;
                }

                const currentTime = Date.now();
                if (currentTime - lastPlanetTime > minPlanetInterval) {
                    createPlanet();
                    lastPlanetTime = currentTime + Math.random() * 2000;
                }

                // Animate planets
                planets.forEach((planet, index) => {
                    // Slower movement for planets
                    planet.position.z += 1.0; 
                    
                    // Scale the planet as it gets closer
                    if (planet.position.z > -1200) {
                        const scaleFactor = 1 - (planet.position.z / -1200);
                        planet.scale.set(scaleFactor, scaleFactor, scaleFactor);
                    }
                    
                    // Remove planets that have passed the camera to maintain performance
                    if (planet.position.z > 200) {
                        scene.remove(planet);
                        planets.splice(index, 1);
                    }
                });
                
                renderer.render(scene, camera);
            }

            // Handle window resizing
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            window.addEventListener('resize', onWindowResize, false);
            
            // Start the animation on window load
            window.onload = function() {
                animate();
            };
        })();
    </script>
</body>
</html>

